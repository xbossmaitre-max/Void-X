const axios = require("axios"); const fs = require("fs"); const yts = require("yt-search"); const path = require("path"); const cacheDir = path.join(__dirname, "/cache"); const tmp = path.join(__dirname, "/tmp"); if (!fs.existsSync(cacheDir)) fs.mkdirSync(cacheDir); if (!fs.existsSync(tmp)) fs.mkdirSync(tmp); module.exports = { config: { name: "ytvid", version: "4.0.0", author: "GoatMart", countDown: 5, role: 0, description: { en: "Search & download YouTube audio or video using your new API", }, category: "media", guide: { en: "{pn} -v <search term>: Download video\n{pn} -a <search term>: Download audio", }, }, onStart: async ({ api, args, event }) => { if (args.length < 2) { return api.sendMessage( "âŒ Usage:\nâ€¢ /ytb -v <search> for video (360p)\nâ€¢ /ytb -a <search> for audio (mp3)", event.threadID, event.messageID ); } const flag = args[0].toLowerCase(); const searchTerm = args.slice(1).join(" "); const isAudio = flag === "-a" || flag === "audio"; const isVideo = flag === "-v" || flag === "video"; if (!isAudio && !isVideo) { return api.sendMessage( "âŒ Invalid flag.\nUse -v for video or -a for audio", event.threadID, event.messageID ); } try { const results = await yts(searchTerm); const videos = results.videos.slice(0, 6); if (videos.length === 0) { return api.sendMessage(`â­• No results for: ${searchTerm}`, event.threadID, event.messageID); } let msg = ""; videos.forEach((v, i) => { msg += `${i + 1}. ${v.title}\nâ± Duration: ${v.timestamp}\nðŸ“º Channel: ${v.author.name}\n\n`; }); api.sendMessage( { body: msg + "ðŸ‘‰ Reply with a number to select.", attachment: await Promise.all( videos.map((v) => downloadThumbnail(v.thumbnail, path.join(tmp, `thumb_${v.videoId}.jpg`)) ) ), }, event.threadID, (err, info) => { global.GoatBot.onReply.set(info.messageID, { commandName: "ytb", messageID: info.messageID, author: event.senderID, videos, isAudio, }); }, event.messageID ); } catch (err) { console.error(err); api.sendMessage("âŒ YouTube search failed.", event.threadID, event.messageID); } }, onReply: async ({ event, api, Reply }) => { await api.unsendMessage(Reply.messageID); api.setMessageReaction("ðŸ”„", event.messageID, () => {}, true); const choice = parseInt(event.body); if (isNaN(choice) || choice < 1 || choice > Reply.videos.length) { return api.sendMessage("âŒ Invalid number.", event.threadID, event.messageID); } const selected = Reply.videos[choice - 1]; const videoUrl = selected.url; try { const apiUrl = `https://musicapiz.vercel.app/music`; const format = Reply.isAudio ? "mp3" : "mp4"; const { data } = await axios.get(apiUrl, { params: { url: videoUrl, type: format } }); if (!data.success || !data.download_url) { throw new Error("âŒ Download URL not received from API."); } const filePath = path.join( cacheDir, Reply.isAudio ? `ytb_audio_${selected.videoId}.mp3` : `ytb_video_${selected.videoId}.mp4` ); await downloadFile(data.download_url, filePath); await new Promise(res => setTimeout(res, 500)); // safety delay api.setMessageReaction("âœ…", event.messageID, () => {}, true); await api.sendMessage( { body: `ðŸŽ¶ Playing: ${data.title}`, attachment: fs.createReadStream(filePath), }, event.threadID, () => fs.unlink(filePath, () => {}), // auto delete after send event.messageID ); } catch (err) { console.error(err); api.sendMessage(`âŒ Download failed: ${err.message}`, event.threadID, event.messageID); } }, }; async function downloadThumbnail(url, savePath) { try { const res = await axios.get(url, { responseType: "stream" }); const writer = fs.createWriteStream(savePath); res.data.pipe(writer); return new Promise((resolve) => { writer.on("finish", () => resolve(fs.createReadStream(savePath))); writer.on("error", () => resolve(null)); }); } catch (err) { console.error("Thumbnail error:", err); return null; } } async function downloadFile(url, savePath) { const writer = fs.createWriteStream(savePath); const response = await axios.get(url, { responseType: "stream" }); return new Promise((resolve, reject) => { response.data.pipe(writer); writer.on("finish", resolve); writer.on("error", reject); }); }
